design notes

rendering responsabilities

a camera knows how to render primitives (lines, points, sprites). 
a Primitive receive a camera and invokes its methods to render itself (like grid).


occlusion culling

occlusion culling must happen in model_view space, not view_proj space. 
occlusion happen at grid-cell level.
so, each cell may keep a pos_view attribute to cache the transformation, because this will be use in many passes, like zordering. 

rendering sequence

if render method in Primitive objects is done through Inmediate Mode calls to camera, it means there is no place here for implement a render queue. 
therefore, render queue must be implemented in two phases: 

first, iterate over all master grid cells, perform culling and create a z-ordered list of visible cells (this may be improved with a quadtree).

second, for each cell to be renderer, iterate over all its objects, creating a local z-ordered list. 

note: there is a step zero.. to render the grid itself. it can be done directly, because it will act as a background for all the other renders that will be over it.


auxiliar objects (vectors and matrices)

there are many methods that require the use of auxiliar temporal records. by example, transform a point may require to multiply by the view matrix, store a temporal result, then multiply by the projection matrix.
this intermediate variable would be created at the fly, but given that this kind of methods will be called potentially hundred of times per frame, it makes sense to try to avoid the creation/destruction of them, and istead of that, to reuse a long-live version. 

to do this, we may declare a set of auxiliar variables at module level, but that would produce some mess if two different objects are using internally the same variable.

another approach would be to declare auxiliar variables per object prototype. using a g_ notation to denotate it. 


